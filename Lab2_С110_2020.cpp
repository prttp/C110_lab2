
/*************************************************************
	Практическое занятие №2 курс С110. Функции.
	Указатели на функции

*************************************************************/

#include <tchar.h>
//#include <cstdio>
//#include <cstdarg>
#include "other.h"


#define	  stop __asm nop
				
int _tmain()
{

	//Задание 1. 
	//Указатели на массивы в качестве аргументов.
	//Напишите два варианта функции печати элементов
	//1. во встроенном двумерном массиве
	//int ar[N][M] = {список инициализаторов};//подумайте - как и где должны быть заданы N и M
	//Вызов функции PrintArray   может выглядеть так:
	{
		
		int ar[N][M] = { {1, 2, 3, 4, 5},
						 {5, 4, 3, 2, 1},
						 {1, 2, 3, 4, 5},
						 {5, 4, 3 ,2, 1} };
		int ar2[][M] = { {1, 2, 3, 4, 5},
						 {5, 4, 3, 2, 1},
						 {1, 2, 3, 4, 5},
						 {5, 4, 3 ,2, 1},
						 {1, 2, 3, 4, 5},
						 {5, 4, 3, 2, 1} };

		//	PrintArray(ar, ... может быть, понадобится передать еще какие-нибудь данные);  //Важно! первый параметр- имя двумерного (!) массива
		PrintArray(ar);

		//2. в динамическом двумерном массиве (обе размерности вычисляются)
		int dN = 4;
		int dM = 5;
		int** dynar = new int* [dN];
		for (int i=0; i < dN; i++) {  // заполнение массива
			dynar[i] = new int[dM];
			for (int j=0; j < dM; j++) {
				dynar[i][j] = j;
			}
			stop
		}
		PrintDynArray(dynar, dN, dM);
		for (int i = 0; i < dN; i++) { // очистка памяти
			delete[] dynar[i];
		}
		delete[] dynar;
		dynar = 0;
	}
	
/////////////////////////////////////////////////////////////////////////////
	//Задание 2.
	//Передача указателя на встроенный массив в качестве параметра функции.
			//Напишите две взаимодополняющие друг друга функции:
			//1.  ... DayOfYear(...)
			//- преобразует день месяца (число,месяц и год задаются в качестве параметров)
			//в порядковый день года(возвращаемое значение)
			//2. ... DayOfMonth(...) - функция преобразует порядковый день года в день месяца
			// (принимает год и порядковый день года в качестве параметров и должна сформировать
			// день месяца и номер месяца и каким-то образом сообщить эти значения вызывающей процедуре)

			//Проверьте работоспособность обеих функций с помощью следующего фрагмента:


			//В процессе вычислений Вам придется учитывать "високосный - невисокосный" год.
			//для проверки "високосности" года имеет смысл создать функцию (isLeepYear)
			//Для этого предлагается в каждую функцию в качестве одного из параметров передавать
			//данные приведенного ниже двухмерного массива nDayTab
	{
		int nDayTab[2][12] = {
			{31,28,31,30,31,30,31,31,30,31,30,31}, //невисокосный год
			{31,29,31,30,31,30,31,31,30,31,30,31} };	//високосный год

		//Вызов функции DayOfYear   может выглядеть так:


		int day = 25, month = 5, year = 1993;
		int numDay = DayOfYear(day, month, year, nDayTab);  //Важно! последний параметр- имя двумерного (!) массива

		//Проверка результата обратной функцией DayOfMonth        //Важно! последний параметр- имя двумерного (!) массива
		day = DayOfMonth(numDay, year, month, nDayTab);

		stop
			/////////////////////////////////////////////////////////////////////////////
				//Задание 3.
				//Задание 3а. Функции с переменным числом параметров.
				//Напишите функцию (дана заготовка VarArgs, не использующая
				// макросы), которая принимает переменное число аргументов
				// типа int и выводит на печать число принятых параметров и
				// их значения.
				// Признаком конца списка является нулевое значение.

			int nN1 = 5, nN2 = 11, nN3 = 4, nN4 = 7, nN5 = -1;
		VarArgs(nN1, 0);
		VarArgs(nN1, nN2, 0);
		VarArgs(nN1, nN2, nN3, nN4, nN5, 0);
		stop


			//Задание 3б. Модифицируйте функцию 3а с помощью макросов
			// va_start, va_arg, va_end
			VarArgsM(nN1, 0);
		VarArgsM(nN1, nN2, 0);
		VarArgsM(nN1, nN2, nN3, nN4, nN5, 0);

	}
///////////////////////////////////////////////////////////////////
	//Тема Указатели на функции

	//Задание 4. Указатель на функцию. "Калькулятор".
	//Напишите функции:
	//1)Sum - принимает два значения double и возвращает сумму
	//этих значений
	//2)Sub- принимает два значения double и возвращает разность
	//этих значений
	//3)Mul - *
	//4)Div - /
	//5)а для возведения в степень можете использовать функцию стандартной библиотеки
	//		- pow(). Подсказка 1: прототип функции находится в <cmath>.
	//		Подсказка 2: стандартная библиотека предоставляет несколько перегруженных
	//		вариантов этой функции, а Вам потребуется сформировать указатель на 
	//		double pow(double, double);

	//Предоставьте пользователю	следующую возможность:
	//пока пользователь хочет пользоваться услугами Вашего калькулятора,
	//он может вводить два значения и знак операции
	//а Вы выводите результат. Результат получаете посредством вызова
	//соответствующей Вашей функции по указателю.
	//Предусмотрите возможность ввода непредусмотренного знака операции
	{
		double x1 = 0;
		double x2 = 0;
		char x3 = 0;
		std::cout << "Enter the first arguement:" << std::endl;
		std::cin >> x1;
		std::cout << "Enter the second arguement:" << std::endl;
		std::cin >> x2;
		std::cout << "Enter the operation sign (+, -, *, / or ^):" << std::endl;
		std::cin >> x3;
		if (x3 == '+' || x3 == '-' || x3 == '*' || x3 == '/' || x3 == '^') {
			double (*pf)(double, double) = 0;
			if (x3 == '+') { pf = Sum; };
			if (x3 == '-') { pf = Sub; };
			if (x3 == '*') { pf = Mul; };
			if (x3 == '/') { pf = Div; };
			if (x3 == '^') { pf = pow; };
			std::cout << pf(x1, x2) << std::endl;
		}
		else { std::cout << "ERROR! The operation sign is incorrect!" << std::endl; }
	}

	stop
		///////////////////////////////////////////////////////////////////
			//Задание 5. Указатель на функцию в качестве аргумента.
			//Дана заготовка функции сортировки любых объектов - Sort.
			//Функция принимает следующие параметры:
			//1) указатель на первый сортируемый элемент
			//2) количество сортируемых элементов
			//3) размер элемента в байтах
			//4) указатель на функцию перестановки элементов
			//5) указатель на функцию сравнения элементов

			//5a. Напишите функцию перестановки двух целых значений -
			// SwapInt, которая принимает два void указателя и 
			//меняет значения местами

			//Напишите функцию сравнения двух целых значений -
			// CmpInt, которая принимает два void указателя и
			//возвращает int результат сравнения: 
			//<0 - первый элемент меньше, чем второй
			//=0 - равны
			//>0 - первый элемент больше, чем второй
	{
		int nAr[5] = {5, 3, 2, 4, 1};	//массив для сортировки

		//Печать исходного массива
		for (int i = 0; i < 5; i++) {
		std::cout << nAr[i] << ' ';
		};
		std::cout << std::endl;
		//Вызов сортировки
		int nTotal = sizeof(nAr) / sizeof(nAr[0]);			//количество элементов в массиве
		Sort(reinterpret_cast<char*>(&nAr[0]), nTotal, sizeof(int), SwapInt, CmpInt);

		//Печать результатов сортировки
		for (int i = 0; i < 5; i++) {
			std::cout << nAr[i] << ' ';
		}
		std::cout << std::endl;
		stop
	}
	
	//Задание 5б. По аналогии с 5а создайте вспомогательные
	//функции - SwapDouble и CmpDouble и вызовите функцию Sort
	//для сортировки массива вещественных значений.
	{
		double nAr[5] = { 5.2, 3.34, 2.1, 4.15, 1.67 };	//массив для сортировки

		//Печать исходного массива
		for (int i = 0; i < 5; i++) {
			std::cout << nAr[i] << ' ';
		};
		std::cout << std::endl;
		//Вызов сортировки
		int nTotal = sizeof(nAr) / sizeof(nAr[0]);			//количество элементов в массиве
		Sort(reinterpret_cast<char*>(&nAr[0]), nTotal, sizeof(double), SwapDouble, CmpDouble);

		//Печать результатов сортировки
		for (int i = 0; i < 5; i++) {
			std::cout << nAr[i] << ' ';
		}
		std::cout << std::endl;
		stop
	}
	
	//Задание 5в*. По аналогии с 5а создайте вспомогательные
	//функции - SwapStr и CmpStr и вызовите функцию Sort
	//для сортировки массива указателей на строки.
		{
			const char* arStr[] = { "QQQ", "SDF", "ABC","Abba", "ENFR","En" };
			for (int i = 0; i < (sizeof(arStr)/sizeof(char*)); i++) {
				std::cout << arStr[i] << ' ';
			};
			std::cout << std::endl;
			int nTotal = sizeof(arStr) / sizeof(char*);
			//Замечание:
			//в массиве линейно лежат АДРЕСА строк, надо передать АДРЕС массива, 
			
			stop
			
			Sort(reinterpret_cast<char*>(arStr), nTotal, sizeof(char*), SwapStr, CmpStr);
			for (int i = 0; i < (sizeof(arStr) / sizeof(char*)); i++) {
				std::cout << arStr[i] << ' ';
			};
			std::cout << std::endl;
			stop
		}
///////////////////////////////////////////////////////////////////
		{
			//Задание 6. Массивы указателей на функцию.
			//Напишите несколько функций вида
			//const char* GetString1();   
			//const char* GetString2();
			//const char* GetString3();
			//const char* GetString4();
			//const char* GetString5();

			//		...., каждая из функций возвращает указатель на свою строку
			//(подумайте - какой адрес Вы имеете право возвращать из функции) со статическим временем существования, указатель на строковый литерал, динамич память 

			// Вам предоставлен код этих функций. 
			//Подумайте:
			//1) все ли они корректны, если нет, то как исправить некорректность
			//2) может быть требуются какие-то дополнительные действия

			//Объявите и проинициализируйте массив указателей на функции
			//GetString1,GetString2...
			const char* (*fArr[5])() = { GetString1, GetString2, GetString3, GetString4, GetString5 };
			//Введите номер функции, которую Вы хотите вызвать:
			int n = 2;




			//Вызовите функцию
			const char* res = fArr[n]();


			//Распечатайте результат
			std::cout << res << std::endl;
			//как очистить хип из вызывающей?
			stop
		}
////////////////////////////////////////////////////////////////////////////
	//Задание 7*.
	//Создайте одномерный массив (размерность вычисляется в процессе
	//выполнения программы), заполните его значениями.
	//Напишите функцию, которая добавляет в массив новое значение только (!) при условии,
	//что такого значения в массиве еще нет. 
	//Подсказка: при этом размер  массива должен увеличиться!
	//Для проверки напишите функцию, которая выводит значения всех элементов на экран
		{
			int n = 5;
			int* Arr = new int[n];
			for (int i = 0; i < n; i++) {
				Arr[i] = i + n;
			}
			stop
			int M = 0;
			std::cout<< "How many elements are you planning to add?" << std::endl;
			std::cin >> M;
			for (int i = 0; i < M; i++) {
				
				AddNew(&Arr, &n);
			}
			PDArray(Arr, n);
		}

///////////////////////////////////////////////////////////////////////////
		{
			//Задание 8.  
			//Рекурсивные функции.
			//8.1.Написать рекурсивную функцию вычисления суммы первых N натуральных чисел. 
			int sum = F81(10);
			//8.2.Написать рекурсивную функцию вычисления количества цифр 10-чного натурального числа
			int num = F82(3567);
			//8.3.Написать рекурсивную функцию для вывода на экран строки в обратном порядке. 
			F83("time");
			std::cout << std::endl;
			//8.4.Написать рекурсивную функцию для вывода на экран строки в прямом (!) порядке.
			F84("unbelievable", (strlen("unbelievable")-1));
			


			stop
		}
	return 0;
}//main

